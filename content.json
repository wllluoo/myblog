{"meta":{"title":"小陀螺的博客","subtitle":null,"description":null,"author":"wllluoo","url":"https://wllluoo.github.io/myblog"},"pages":[],"posts":[{"title":"js中的事件委托","slug":"事件委托","date":"2018-02-23T16:00:00.000Z","updated":"2018-02-25T03:05:51.000Z","comments":true,"path":"2018/02/24/事件委托/","link":"","permalink":"https://wllluoo.github.io/myblog/2018/02/24/事件委托/","excerpt":"","text":"","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://wllluoo.github.io/myblog/tags/js/"}]},{"title":"特效：浏览器滚动时，文字滑入特效","slug":"fade","date":"2017-10-21T16:00:00.000Z","updated":"2018-02-17T15:02:12.000Z","comments":true,"path":"2017/10/22/fade/","link":"","permalink":"https://wllluoo.github.io/myblog/2017/10/22/fade/","excerpt":"","text":"1.首先要获取内容进入屏幕边缘的零界点 可以通过 滚轮移动端距离 + 浏览器窗口大小 &gt; 元素距离页面顶部的距离来进行判断。 监听浏览器滚动事件： 123456//给页面绑定滑轮滚动事件if (document.addEventListener) &#123;//firefox document.addEventListener('DOMMouseScroll', scrollFun, false);&#125;//滚动滑轮触发scrollFunc方法 //ie 谷歌window.onmousewheel = document.onmousewheel = scrollFun; 若是移动端还需加上：1document.addEventListener('scroll',scrollFun, false); 2.处理滚动事件：当元素进入浏览器边缘时，对该元素添加一个class，令其具有滑入的特效。因此给需要有滑入特效的元素事先增加自定义的class，以便选中。 1234function revealOnScroll() &#123; var scrolled = $(window).scrollTop(); // 获取滚动条移动的距离，即移动的位移 scrollFadeUpFun(scrolled, 'fade’); // 选中所有class为fade的元素 &#125; 3.获取浏览器高度：1var windowHeight = document.body.clientHeight; 4.操作元素：12345678910function scrollFadeUpFun(scrolled, element) &#123; $(\".\" + element).each(function() &#123; var $this = $(this), fadeOffsetTop = $this.offset().top; // 该元素在dom中距离顶部的距离 if (windowHeight + scrolled &gt; fadeOffsetTop) &#123; // 当 窗口高度 + 滚动的高度 &gt; 元素在dom中距离顶部的距离 即进入浏览器的下边缘时 $this.addClass('fade_up'); &#125; &#125;); &#125; 5.html中, 定义需滑入的元素1234&lt;div class='fade'&gt; &lt;p&gt;回顾所来径&lt;/p&gt; &lt;p&gt;苍苍横翠薇&lt;/p&gt;&lt;/div&gt; 6.给元素增加滑入渐变特效，如下所示，即元素的透明度从0.1变为1, 位置从80px还原为0px。12345678910111213元素自身样式 .fade &#123; display: block; transform: translateY(80px); opacity: 0.1; &#125; 定义滑入样式 .fade_up &#123; transform: translateY(0px); -webkit-transition: -webkit-transform .8s ease-out, opacity .8s ease-in; transition: transform .8s ease-out, opacity .8s ease-in-out; opacity: 1; &#125;","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://wllluoo.github.io/myblog/tags/js/"}]},{"title":"typescript测试之小试牛刀","slug":"typescript","date":"2017-09-02T16:00:00.000Z","updated":"2018-02-17T15:02:46.000Z","comments":true,"path":"2017/09/03/typescript/","link":"","permalink":"https://wllluoo.github.io/myblog/2017/09/03/typescript/","excerpt":"","text":"TypeScript基于接口的强类型定义，能很好的弥补javascript语言的先天不足，并且遵循了es6标准，因此只要掌握了 TypeScript ，就相当于掌握了 JavaScript 语言的最新标准，并且能在老式浏览器上完整运行（先吹一波）。 1.变量定义1234const test: string = 'nihao'; // 字符串const aaa: number = 12121; // 数字const member: string[] = ['111', '222', '3333']; // 字符串类型的数组console.log(member.toString()); // 111,222,3333 若不按给定的类型定义，将报错，如下：12const aaa: number = '12121'; // 报错： Type '\"12121\"' is not assignable to type 'number'. 2.接口的使用例1:12345678910interface SuperHero &#123; realName: String; superName: String;&#125;const superman: SuperHero = &#123; realName: 'spiderman', // 需给出符合 SuperHero接口的数据类型的定义 superName: 'superman',&#125;;console.log(`$&#123;superman.realName&#125; is a $&#123;superman.superName&#125;`);// spiderman is a superman 例2:123456789101112interface SuperHero &#123; realName: String; superName: String; &#125;// 定义一个 SuperHero类型的数组, SuperHero的值，需是符合SuperHero借口定义的对象。const SuperHeroes: SuperHero[] = []; SuperHeroes.push(&#123; realName: 'Ah way', superName: 'superman', &#125;);console.log(`$&#123;SuperHeroes[0].realName&#125; is a $&#123;SuperHeroes[0].superName&#125;`);// Ah way is a superman 3.方法的使用：例1:12345// 定义一个接收两个number参数的方法，并返回数字类型的和const getSum = function (num1: number, num2: number): number &#123; return num1 + num2;&#125;;const sum1 = getSum(2, 5); // 7 例2:123456789// 定义一个方法，其中num2 赋值为2, num3可不传或为number类型的参数const getSum = function (num1: number, num2 = 2, num3?: number): number &#123; if (typeof num3 !== 'undefined') &#123; return num1 + num2 + num3; &#125; return num1 + num2;&#125;;const sum1 = getSum(5); // 7const sum2 = getSum(5, 2, 1); // 8 例3:12345// 定义一个方法，接收多个number的参数，并将所有参数整合为数组const getSum = function (...nums: number[]): void &#123; const sum = nums.reduce((a, b) =&gt; a + b, 0); &#125;;getSum(5, 2, 1); // 8 4.类继承接口的使用123456789101112// 定义一个有drive参数的Vehicle接口，其中drive可以是任意的数据类型interface Vehicle &#123; drive: any;&#125;class Car implements Vehicle &#123; // 定义一个Car继承Vehicle接口 constructor(private wheels: number)&#123;&#125; //构造器去接收wheels参数 drive() : void &#123; console.log('this.wheels', this.wheels); &#125;&#125;var car = new Car(4); // 实例化一个Car对象car.drive(); // this.wheels : 4 5.接收固定参数的方法1234567function GetType&lt;T&gt;(val: T): string &#123; return typeof (val);&#125;const testStr = 'test';const testNum = 123;GetType(testStr); // stringGetType(testNum); // number 6. 方法继承接口的使用123456789101112131415interface Vehicle &#123; drive: any;&#125;class Car implements Vehicle &#123; // constructor(private wheels: number)&#123;&#125; drive(): void &#123; console.log('this.wheels', this.wheels); &#125;&#125;var car = new Car(4); function GetWheels&lt;w extends Vehicle&gt; (veh: w): number &#123; return veh.drive();&#125;GetWheels(car); // this.wheels : 4 7. 接收固定参数的类12345678910// 构造一个GenericNumber类，其中有add方法，接收一个参数，作为add方法参数的类型class GenericNumber&lt;T&gt;&#123; add: (val1: T, val2: T) =&gt; T;&#125;var aNumber = new GenericNumber&lt;number&gt;(); // new 一个GenericNumber类的实例，并定义add方法接收Number类型的参数aNumber.add = function(x, y) &#123; return x + y;&#125;console.log(aNumber.add(5, 4)); // 9console.log(aNumber.add('5', '4')); // 报错 Argument of type '\"5\"' is not assignable to parameter of type 'number'.","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://wllluoo.github.io/myblog/tags/TypeScript/"}]},{"title":"react中通过displayName改变组件名","slug":"reactDisplay","date":"2017-08-27T16:00:00.000Z","updated":"2018-02-17T15:13:29.000Z","comments":true,"path":"2017/08/28/reactDisplay/","link":"","permalink":"https://wllluoo.github.io/myblog/2017/08/28/reactDisplay/","excerpt":"","text":"先讲一点react的基础部分： 1. react中创建组件的写法:var a = &lt;Component {...props} /&gt;，实质上是React调用createElement方法，生成一个虚拟的DOM元素。等同于如下：var a = React.createElement(Component, props); 2. 创建类的写法： class Component{ }，其本质是一个方法， 在babel中转化如下： 123456789 function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; // 类型检测 throw new TypeError(\"Cannot call a class as a function\"); &#125; &#125; var Component = function Component() &#123; _classCallCheck(this, Component);&#125;; 3. 在DOM中渲染一个button按钮：123var child = React.createElement('p', &#123; id: 'bbb' &#125;, 'click me');var app = React.createElement('button', &#123; id: 'aaa', onClick: () =&gt; console.log(1111) &#125;, child);ReactDOM.render(app, document.getElementById('root')); 上述将生成一个包裹着p标签的button组件。ReactElement: 一个描述DOM节点或component实例的字面级对象。创建并返回一个新的react element元素及虚拟DOM对象。type可以是一个普通的标签名如div或span, 亦可以是react组件类型（class或是function)。 4. 提供一个改变组件名字的方法：12345678910111213141516class ButtonForTest extends Component &#123; // 写一个class供addName方法使用，也可以是一个function render() &#123; return ( &lt;Button&gt;1111&lt;/Button&gt; ) &#125;&#125; function addName(name, Component) &#123; // 接收一个名字，及一个组件 function WithName(props) &#123; return &lt;Component &#123;...props&#125; /&gt;; &#125; WithName.displayName = `$&#123;name&#125;`; // 改变function 的名字,即改变WithName类的名字。 return WithName;&#125;const newName = &#123; key: addName('NewName', ButtonForTest) &#125;;const NewComponent = &lt;newName.key /&gt;; // -》 var c = React.createElement(newName.key, null); 上诉NewComponent所得为NewName组件下包含着ButtonForTest组件。 笔者一直感到奇怪，NewComponent获得的是一个带有display属性的function，并不是一个class，为什么也可以渲染出来呢。 其实上面已经说到了，类的本质就是一个方法。 &lt;newName.key /&gt;转化为js的写法是 React.createElement(newName.key, null)，createElement接收三个参数（type, config, children）, type属性为字符串时，它代表是普通的节点，如div,span。type属性为一个函数或一个类时，它代表自定义的节点。因此上述方法即是获得一个addName方法返回的组件，其中对所要包裹的组件，(即第二个参数)外部包裹一层名为NewName 的组件。 5. 简单看一下react中createElement部分：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990ReactElement.createElement = function(type, config, children) &#123; var propName; // Reserved names are extracted var props = &#123;&#125;; var key = null; var ref = null; var self = null; var source = null; if (config != null) &#123; if (hasValidRef(config)) &#123; ref = config.ref; &#125; if (hasValidKey(config)) &#123; key = '' + config.key; &#125; self = config.__self === undefined ? null : config.__self; source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object // 将config里的属性复制到props中去 for (propName in config) &#123; if ( hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName) ) &#123; props[propName] = config[propName]; &#125; &#125; &#125; // Children can be more than one argument, and those are transferred onto // the newly allocated props object. //处理children,全部挂载到props的children属性上 //支持两种写法，如果只有一个参数，直接赋值给children，否则做合并处理 var childrenLength = arguments.length - 2; if (childrenLength === 1) &#123; props.children = children; &#125; else if (childrenLength &gt; 1) &#123; var childArray = Array(childrenLength); for (var i = 0; i &lt; childrenLength; i++) &#123; childArray[i] = arguments[i + 2]; &#125; if (__DEV__) &#123; if (Object.freeze) &#123; Object.freeze(childArray); &#125; &#125; props.children = childArray; &#125; // Resolve default props if (type &amp;&amp; type.defaultProps) &#123; var defaultProps = type.defaultProps; for (propName in defaultProps) &#123; if (props[propName] === undefined) &#123; props[propName] = defaultProps[propName]; &#125; &#125; &#125; if (__DEV__) &#123; if (key || ref) &#123; if ( typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE ) &#123; var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type; if (key) &#123; defineKeyPropWarningGetter(props, displayName); &#125; if (ref) &#123; defineRefPropWarningGetter(props, displayName); &#125; &#125; &#125; &#125; return ReactElement( // 返回ReactElement对象供React使用。 type, key, ref, self, source, ReactCurrentOwner.current, props, );&#125;; 官方有更详尽的讲解：https://facebook.github.io/react/docs/react-api.html#createelement","categories":[],"tags":[]},{"title":"如何在vue中使用highcharts--vue2-highcharts","slug":"assign","date":"2017-08-16T16:00:00.000Z","updated":"2018-02-18T14:43:20.000Z","comments":true,"path":"2017/08/17/assign/","link":"","permalink":"https://wllluoo.github.io/myblog/2017/08/17/assign/","excerpt":"","text":"1.首先。需要npm i -s vue2-highcharts，安装到项目所需的依赖中。2.然后：首先参考官网给出的例子可以满足你的基本上所有的需求了。3.具体代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;template&gt; &lt;vue-highcharts :options=\"options\" ref=\"lineCharts\"&gt;&lt;/vue-highcharts&gt; &lt;button @click=\"load\"&gt;load&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import VueHighcharts from 'vue2-highcharts'const asyncData = &#123; name: 'Tokyo', marker: &#123; symbol: 'square' &#125;, data: [7.0, 6.9, 9.5, 14.5, 18.2, 21.5, 25.2, &#123; y: 26.5, marker: &#123; symbol: 'url(http://www.highcharts.com/demo/gfx/sun.png)' &#125; &#125;, 23.3, 18.3, 13.9, 9.6]&#125;export default&#123; components: &#123; VueHighcharts &#125;, data()&#123; return&#123; options: &#123; chart: &#123; type: 'spline' &#125;, title: &#123; text: 'Monthly Average Temperature' &#125;, subtitle: &#123; text: 'Source: WorldClimate.com' &#125;, xAxis: &#123; categories: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'] &#125;, yAxis: &#123; title: &#123; text: 'Temperature' &#125;, labels: &#123; formatter: function () &#123; return this.value + '°'; &#125; &#125; &#125;, tooltip: &#123; crosshairs: true, shared: true &#125;, credits: &#123; enabled: false &#125;, plotOptions: &#123; spline: &#123; marker: &#123; radius: 4, lineColor: '#666666', lineWidth: 1 &#125; &#125; &#125;, series: [] &#125;; &#125; &#125;, methods&#123; load()&#123; let lineCharts = this.$refs.lineCharts; lineCharts.delegateMethod('showLoading', 'Loading...'); setTimeout(() =&gt; &#123; lineCharts.addSeries(asyncData); lineCharts.hideLoading(); &#125;, 2000) &#125; &#125;&#125;&lt;/script&gt; 这里可以使用异步的数据，比如从接口取数据，或者从父级传递下来。要注意的是asyncData需要是一个对象，然后lineCharts.removeSeries（）每调用一次就会清掉一个已有的曲线","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://wllluoo.github.io/myblog/tags/vue/"}]},{"title":"mac下开启Atom live server 服务","slug":"liveServer","date":"2017-07-31T16:00:00.000Z","updated":"2018-02-18T14:46:42.000Z","comments":true,"path":"2017/08/01/liveServer/","link":"","permalink":"https://wllluoo.github.io/myblog/2017/08/01/liveServer/","excerpt":"","text":"在mac环境下，开启atom插件atom live server 服务，步骤如下： 1.安装atom live server后重启atom。2.打开命令面板(快捷键:cmd + shift + p), 输入“incompatible packages: view”。3.在下拉列表中选中live server，并点击“Rebuild”按钮。4.确认启动后，将开启live server服务。","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://wllluoo.github.io/myblog/tags/工具/"}]}]}